# SORCH ガイド（この1本だけ追えばOK）

このガイドは、資料が点在して迷子になるのを避けるために、
「何ができていて、どこを見て、どう動かすか」を **ここに集約**しています。

## 1. 読む順番（最短）
1. 仕様（ゴール/KPI）: [docs/spec/仕様書.md](spec/%E4%BB%95%E6%A7%98%E6%9B%B8.md)
2. いまの成果（何ができたか）: [docs/project/成果サマリ.md](project/%E6%88%90%E6%9E%9C%E3%82%B5%E3%83%9E%E3%83%AA.md)
3. 用語が辛い場合: [docs/project/用語集.md](project/%E7%94%A8%E8%AA%9E%E9%9B%86.md)

## 2. 現在地（いま何ができている？）
### 2.1 遅延計測（仕様書 Phase 1 / Step 1.0）
- stop遅延を測り、ログとレポートとして保存できる

### 2.2 短期記憶の探索（仕様書 Phase 2 / Step 2.2）
- MC（[用語集](project/%E7%94%A8%E8%AA%9E%E9%9B%86.md#glossary-mc)）で短期記憶の強さを測り、探索→CSV→レポート化まで回せる

### 2.3 Readout/次元削減（仕様書 Phase 2 / Step 2.3）
- Readout（[用語集](project/%E7%94%A8%E8%AA%9E%E9%9B%86.md#glossary-readout)）に渡す状態ベクトル（[用語集](project/%E7%94%A8%E8%AA%9E%E9%9B%86.md#glossary-state-vector)）を切り替えてMC比較できる
- Random Projection（[用語集](project/%E7%94%A8%E8%AA%9E%E9%9B%86.md#glossary-random-projection)）で次元削減した場合の劣化も評価できる

暫定推奨（軽さ優先の現実案）:
- `state_mode=v+spike` + `proj_out_dim=200`

### 2.4 オンライン学習（仕様書 Phase 2 / Step 2.4）
- RLS（[用語集](project/%E7%94%A8%E8%AA%9E%E9%9B%86.md#glossary-rls)）のコア実装があり、オンライン学習のスモーク実験を回せる

### 2.5 運動野（仕様書 Motor Cortex）
- 設計方針: Orchestratorは「文章」に加えて **Speech Plan（話し方メタ情報）** を渡し、抑揚/間/付け足しはMotor側の実装で表現する
	- 目的: Orchestratorの学習を複雑にしすぎない
	- 仕様: [docs/spec/仕様書.md](spec/%E4%BB%95%E6%A7%98%E6%9B%B8.md) の「Orchestrator → Motor（Speech Plan）」および「運動層仕様」を参照

## 3. 生成物（ログ/CSV/レポート）はどこ？
原則として **outputs/** 配下に保存します。

### 3.1 遅延計測（Stop Latency）
- 遅延計測ログ（JSONL）: [outputs/phase1/latency/](../outputs/phase1/latency/)
- 遅延計測レポート（Markdown）: [outputs/phase1/report/Phase1_測定結果.md](../outputs/phase1/report/Phase1_%E6%B8%AC%E5%AE%9A%E7%B5%90%E6%9E%9C.md)

### 3.2 MC（Memory Capacity）
- MC生データ（CSV）: [outputs/phase2/mc/runs/](../outputs/phase2/mc/runs/)
- MCレポート（Markdown）: [outputs/phase2/mc/reports/](../outputs/phase2/mc/reports/)

### 3.3 RLS（Online Readout）
- RLS生データ（CSV）: [outputs/phase2/rls/runs/](../outputs/phase2/rls/runs/)
- RLSレポート（Markdown）: [outputs/phase2/rls/reports/](../outputs/phase2/rls/reports/)

### 3.4 Phase 3（Stop優先度制御）
- Stopイベントログ（JSONL）: [outputs/phase3/](../outputs/phase3/)

## 4. 実行（コマンド最小）
### 4.1 テスト
- `pytest -q`

### 4.2 遅延計測（ドライラン）
- `python -m sorch.bench.latency_bench --dry-run --seconds 5`

### 4.3 MC（スモーク）
- `python -m sorch.bench.mc_sweep --n 50 --steps 2000 --washout 200 --max-delay 50 --tauF-ms 200 --tauD-ms 1000 --w-scale 1.0 --out outputs/phase2/mc/runs/phase2_mc_smoke.csv`

### 4.4 Phase 3（マルチプロセスStopデモ）
- デバイス一覧: `python -m sorch.runtime.phase3_demo --list-devices`
- ドライラン（デバイス不要）:

	- `python -m sorch.runtime.phase3_demo --dry-run --seconds 5 --stop-mode hard --resume-after-ms 0 --output outputs/phase3/stop_events.jsonl`

- 実機（例: ノイズを出し、声を出したら停止）:

	- `python -m sorch.runtime.phase3_demo --seconds 10 --output-mode noise --output-gain 0.02 --stop-mode hard --resume-after-ms 0 --input-device <mic> --output-device <spk> --output outputs/phase3/stop_events.jsonl`

`--stop-mode`:
- `mute`: 即時無音化のみ（ストリームは継続）
- `hard`: 即時無音化 + 出力ストリーム停止/close（必要なら再open）

## 5. 手順書（必要なものだけ）
### 5.1 Phase 1: 遅延計測ベンチ手順
- [docs/howto/Phase1_遅延計測ベンチ_手順.md](howto/Phase1_%E9%81%85%E5%BB%B6%E8%A8%88%E6%B8%AC%E3%83%99%E3%83%B3%E3%83%81_%E6%89%8B%E9%A0%86.md)

### 5.2 Phase 2: MC探索手順
- [docs/howto/Phase2_MC探索_手順.md](howto/Phase2_MC%E6%8E%A2%E7%B4%A2_%E6%89%8B%E9%A0%86.md)

## 6. ベンチ/実験スクリプト（`python -m sorch.bench.*`）
目的: 実装の良し悪しを、主観ではなく **ログ（JSONL/CSV）と集計レポート（Markdown）**で判断できるようにする。

### 6.1 遅延計測（Stop Latency）
- デバイス一覧: `python -m sorch.bench.latency_bench --list-devices`
- ドライラン: `python -m sorch.bench.latency_bench --dry-run --seconds 5`
- 実機（無音出力）:

  - `python -m sorch.bench.latency_bench --seconds 20 --frames 128 --output-mode silence --output outputs/phase1/latency/latency_events.jsonl`

### 6.2 MC探索（Memory Capacity）
- 1条件だけ（CSVに1行）: `python -m sorch.bench.mc_sweep ... --out outputs/phase2/mc/runs/<name>.csv`
- まとめてグリッド: `python -m sorch.bench.mc_search ... --out outputs/phase2/mc/runs/<name>.csv`
- 粗→細の2段階: `python -m sorch.bench.mc_refine ... --out outputs/phase2/mc/runs/<name>.csv`
- 状態ベクトル/投影の比較: `python -m sorch.bench.mc_project --state-modes 'v,spike,v+spike,...' --proj-dims 0,200 ...`
- 集計レポート（1本）: `python -m sorch.bench.mc_report --csv ... --out outputs/phase2/mc/reports/<name>_report.md`
- 集計レポート（全CSVまとめて）: `python -m sorch.bench.mc_report_all --overwrite --topk 15`

### 6.3 オンライン学習（RLS）
- スモーク（暫定推奨のstate設定）:

	- `python -m sorch.bench.rls_online --preset convo_spiking --n 120 --steps 3000 --washout 300 --seed 0 \
			--state-mode v+spike --proj-out-dim 200 \
			--delays 1,5,10,20,40,80,120 \
		--out outputs/phase2/rls/runs/phase2_rls_online_smoke.csv`

	- 補足: 推奨は `--update-mode block --update-every 10 --lam 1.0 --delta 0.01`（デフォルト）
		- 忘却あり（`lam<1`）は、まず `--lam 0.999` から（`lam<=0.995` は今回のMCベンチ設定では崩れやすい）
		- 参考レポート: [outputs/phase2/rls/reports/phase2_rls_online_block_lam_sweep_repeats5_report.md](../outputs/phase2/rls/reports/phase2_rls_online_block_lam_sweep_repeats5_report.md)

## 7. MC（Memory Capacity）をやさしく（例え話と図）
### 7.1 MCは何を測る？
MCは「今のリザーバ状態を見れば、**少し前の入力**をどれだけ思い出せるか」の点数です。
大きいほど「短期記憶が強い」と解釈します（ただし同じ設定同士で比較するのが安全です）。

### 7.2 図で見る（入力→リザーバ→“過去当て”）

```text
(入力) u(t) ──▶ [ リザーバ（STP付き） ] ──▶ 状態 x(t)
	 │                                       │
	 ├── 「t-1 の入力って何だった？」 ◀──────┤
	 ├── 「t-2 は？」               ◀──────┤
	 └── 「t-k は？」               ◀──────┘

k = 1..max_delay の “過去当て” を合計したのがMC
```

### 7.3 よくあるつまずき
- `spike_rate=0` は「動いていない（発火していない）」可能性が高い

	- 用語: spike_rate（[用語集](project/%E7%94%A8%E8%AA%9E%E9%9B%86.md#glossary-spike-rate)）

  - 対策: `--v-threshold` を下げる / `--input-bias` を付ける / `--dc-bias` を入れる

### 7.4 例え話
#### 7.4.1 例えA: メモ帳
- 入力 = その瞬間に見たメモ（1行ずつ流れてくる）
- リザーバ = メモ帳の“ページ”が勝手に書き換わる仕組み
- MCが高い = いまのページを見れば、数行前まで推測できる
- MCが低い = いまのページから、前の内容が想像できない

#### 7.4.2 例えB: 音の「余韻（リバーブ）」
- 入力 = 叩いた音
- リザーバ = 部屋の響き
- MCが高い = 今の響きに、さっきの音の影響が残っている（余韻がある）
- MCが低い = 余韻がすぐ消える（情報が残らない）

### 7.5 何が“良い”の？（目標のイメージ）
MCは“絶対値”より、**同じ条件の中での比較**が安全です。
- 同じ `n / steps / washout / max_delay` の中で MC が高い設定を「短期記憶が強い候補」と見る
- `std`（ばらつき）が小さいほど「安定して良い」

### 7.6 パラメータの直感（ざっくり）
#### 7.6.1 STPの時定数 `tauF_ms` と `tauD_ms`
STP（[用語集](project/%E7%94%A8%E8%AA%9E%E9%9B%86.md#glossary-stp)）は「通りやすさ」が時間で変わる仕組みです。
- `tauF_ms`（Facilitation）: “一度通ると、しばらく通りやすくなる”残り方
- `tauD_ms`（Depression）: “使うと枯れて、回復するまで通りにくい”回復の遅さ

例え（蛇口）:
- Facilitation: 何度か操作するとコツが掴めて勢いが増す
- Depression: 使いすぎると水圧が落ちて、戻るまで時間がかかる

#### 7.6.2 `w_scale`（結合の強さ）
- 小さすぎる: 影響が弱く、状態が単調になりやすい
- 大きすぎる: 暴れて不安定になりやすい

#### 7.6.3 `spike_rate`（発火率）
- ほぼ0: そもそも動いていない（死んでいる）可能性 → MCも伸びにくい
- 高すぎ: ずっと同じ高活動で“飽和”している可能性 → これも記憶が出にくいことがある

	- 用語: spike_rate（[用語集](project/%E7%94%A8%E8%AA%9E%E9%9B%86.md#glossary-spike-rate)）

## 8. 運用（測定→改善の回し方）
### 8.1 原則
- 先に実測し、数字（特にp95/p99）で判断する
- 平均ではなくテールレイテンシとジッタをKPIにする
- 長時間実験は、先にスモーク（数秒〜数十秒）→ 次に本番（数分〜）

### 8.2 遅延計測（Stop Latency）の回し方
1. ベンチを回してベースライン取得
2. 誤検知（FP）を潰す（特徴量・閾値・ゲート条件）
3. レイテンシの分解を進める（I/O・前処理・判定・停止）
4. 必要ならホットパスをネイティブ化

### 8.3 誤検知（FP）チューニングの扱い（方針）
- 当面は「測れる」「止められる」を優先し、ReflexはDSP-firstで暫定実装に留める
- 将来は軽量SNN（SpikingJelly）によるReflex Circuitへ置換する前提
- 本格的なFPチューニング（咳払い/打音など）は、SNN版Reflexへ置換するタイミングで集中的に実施する
	- 理由: SNN化で特徴量・閾値・状態表現が変わり、DSP段階で詰めても作業が重複しやすい

## 9. 次にやること（仕様に対するギャップ）
- Step 1.2: TTSを含む“本当の停止”（Hard Stop）の測定
- Step 2.3/2.4: Readout設計（[用語集](project/%E7%94%A8%E8%AA%9E%E9%9B%86.md#glossary-readout)）とオンライン学習（RLS: [用語集](project/%E7%94%A8%E8%AA%9E%E9%9B%86.md#glossary-rls)）
- Step 2.2: 入力パターン生成（疑似会話テンポ）

