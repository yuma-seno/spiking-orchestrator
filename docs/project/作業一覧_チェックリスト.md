# 作業一覧（チェックリスト）

このチェックリストは **作業の過程で随時追加・更新していく「生きたドキュメント」** です。
- 完了した項目はチェック済みにします。
- 状況メモは **「対応中」または「スキップ（理由の明示）」** を目的として、項目の下にのみ記載します。
- 完了した作業や、スキップしていない未着手項目には原則メモを書きません（必要ならチェックリスト外のメモ/Issueへ）。
- 新しいタスクが見つかったら、このファイルに遠慮なく追記してOKです。

---

## 環境（事前準備）
このプロジェクトを「再現可能に動かす」ための準備です。まずは開発環境と依存関係が揃っていることを確認します。
- [x] Dev Container（python 3.12）で開発できる
- [x] 依存関係インストール（requirements）
- [x] 音声デバイス共有（/dev/snd）確認

## ドキュメント整備
迷子にならないための運用ルールです。出力先や挙動を変えたら「リンクが切れていないか」「仕様書が古くなっていないか」をここで担保します。
- 出力場所やファイル名を変えたら [docs/ガイド.md](../%E3%82%AC%E3%82%A4%E3%83%89.md) と [README.md](../../README.md) のリンク整合を確認すること
- 仕様/挙動が変わったら [docs/spec/仕様書.md](../spec/%E4%BB%95%E6%A7%98%E6%9B%B8.md) を更新

## Phase 1: ベンチマークと反射回路の実装
最初に「止める」を測れる状態にし、誤検知しにくい停止ロジックの土台を作るフェーズです（体感品質の最重要部分）。

### ドキュメント更新（Phase 1）
Phase 1で増えたコマンドや成果物（ログ/レポート）を、あとから誰でも辿れるようにドキュメントへ反映します。
- [x] 行う作業についての手順書を作成
- [x] 作成したコマンド/オプションを [docs/ガイド.md](../%E3%82%AC%E3%82%A4%E3%83%89.md) の「すぐ動かす」「コマンド」節に追加
- [x] 行った作業の成果を [docs/project/成果サマリ.md](../project/%E6%88%90%E6%9E%9C%E3%82%B5%E3%83%9E%E3%83%AA.md) に反映
- [x] ベンチマーク等を行ったら、結果レポートを outputs に保存

### Step 1.0: 遅延計測ベンチマーク（仕様書 Step 1.0）
「どれくらい速く止められるか」を数値で測るためのベンチです。以後の改善は、ここで取れるログ/レポートを根拠に進めます。
- [x] ベンチCLI実装（マイク→特徴量→判定→停止）
- [x] p50/p95/p99/std を算出できる
- [x] stopイベントを JSONL に保存できる
- [x] デバイス一覧/デバイス指定オプション追加（入力/出力 index）
- [x] ビープ対策（デフォルト無音出力）
- [x] 実機で計測実施（入力4/出力0）
- [x] 計測結果を保存（outputs配下）

### Step 1.1: Reflex Circuit プロトタイプ（暫定DSP → 将来SNNへ）（仕様書 Step 1.1）
誤検知を抑えつつ即時にStopを出す「安全装置」の段階です。まずはDSPで堅く作り、将来SNN版に差し替えます。
- [x] 適応閾値（EMA）
- [x] 不感期（hold-off）
- [x] ループバック抑制フック（loopback_active）
- [x] ユニットテスト（Reflex/特徴量）
- [ ] Reflex Circuit をSNN版へ置換（SpikingJelly, 固定重み + 安全ロジック）
- [ ] SNN版Reflexで誤検知チューニング（咳払い/打音など）

### Step 1.2: 停止制御（Hard Stop：TTS等を含む停止）（仕様書 Step 1.2）
実際の音声再生（TTS/デバイス）まで含めて「本当に止まる」ことを保証する段階です。E2E（端から端まで）での測定がゴールになります。
- [ ] VOICEVOX等の実TTS再生キューのクリア
- [ ] オーディオデバイスのリセット（APIレベルでプリエンプティブ確認）
- [ ] 停止のエンドツーエンド測定（TTSを含む）

---

## Phase 2: 記憶回路と文脈制御
会話の「間」や「テンポ」を、短期記憶（STP付きリザーバ）として作り込み、数値（MC/R^2）で比較・改善できるようにするフェーズです。

### ドキュメント更新（Phase 2）
Phase 2はオプションや成果物が増えやすいので、推奨設定・実行例・レポートの場所をこのフェーズ内で整理しておきます。
- [x] 行う作業についての手順書を作成
- [x] 作成したコマンド/オプションを [docs/ガイド.md](../%E3%82%AC%E3%82%A4%E3%83%89.md) の「すぐ動かす」「コマンド」節に追加
- [x] 行った作業の成果を [docs/project/成果サマリ.md](../project/%E6%88%90%E6%9E%9C%E3%82%B5%E3%83%9E%E3%83%AA.md) に反映
- [x] ベンチマーク等を行ったら、結果レポートを outputs/phase2/ 配下に保存

### Step 2.1: STPニューロン（仕様書 Step 2.1）
STP（短期可塑性）の内部状態を持つニューロン/リザーバを実装する段階です。以後の探索はここで作った土台を前提に進みます。
- [x] `STP_LIFNode` 実装（Tsodyks–Markram）
- [x] ユニットテスト追加

### Step 2.2: MC探索（仕様書 Step 2.2）
短期記憶が強いパラメータを「当てずっぽう」ではなく探索で見つける段階です。結果はCSV/レポートとして残し、比較可能にします。
- [x] 500〜1000ニューロンのリザーバ構築
- [x] 入力パターン生成（ランダム/疑似会話テンポ）
- [x] MCスコア計測（過去入力の復元）
- [x] 探索パラメータ sweep（tau_F/tau_D/W_scale）
- [x] 結果をCSV/JSONで保存
- [x] MC探索スクリプトの手順書を整備
- [x] MCグリッド探索（複数条件を一括実行）
- [x] MC 2段階探索（粗→細、自動リファイン）
- [x] MC結果の集計（Top候補レポート生成）
- [x] `convo` 入力で発火が出ないケースのガード（`spike_rate=0` の WARNING 追加）
- [x] 発火を出しやすい `convo_spiking` プリセット追加（`v_threshold=0.25`, `dc_bias=0.25` 自動セット）

### Step 2.3: Readout / 次元削減（仕様書 Step 2.3）
リザーバ状態から何を読み出すか（状態ベクトル）と、重さをどう抑えるか（投影による次元削減）を決める段階です。
- [x] Random Projection実装
- [x] `mc_report` が `proj_out_dim` を理解してレポート化できるよう拡張（投影次元=out_dim）
- [x] `mc_project` を repeats（複数seed）で実行し、proj_out_dim ごとのMC劣化をレポート化（convo_spiking基準）
	- レポート: [outputs/phase2/mc/reports/phase2_mc_project_convo_spiking_repeats5_report.md](../../outputs/phase2/mc/reports/phase2_mc_project_convo_spiking_repeats5_report.md)
- [x] 「採用できる最小 proj_out_dim」の目安を決める（例: fullの90%維持、など）
	- repeats5（n=120/steps=3000）の目安: proj_out_dim=200 はほぼ full、proj_out_dim=100 は約83%程度、50/25 は大きく劣化
	- 暫定結論: 90%維持を狙うなら proj_out_dim=200 を基本（より攻めるなら 100 も候補）

- [x] Readoutが参照する状態ベクトル設計（どの信号を含めるか）
	- [x] STPリザーバの内部状態トレース取得（`run_traces`: v/spike/u/r/eff）
		- v/spike: ニューロンの状態（膜電位/発火）
		- u/r/eff: STPの内部状態（[用語: STP](%E7%94%A8%E8%AA%9E%E9%9B%86.md#glossary-stp)）
	- [x] `mc_project` に `--state-modes` を追加し、`state_mode/state_dim` をCSVへ保存（[用語: state_mode](%E7%94%A8%E8%AA%9E%E9%9B%86.md#glossary-state-mode)）
	- [x] `mc_report` が `state_mode/state_dim` を表示できるよう拡張
	- [x] state_mode 比較を repeats5 で実行してレポート化（convo_spiking基準）
		- レポート: [outputs/phase2/mc/reports/phase2_mc_state_modes_smoke_report.md](../../outputs/phase2/mc/reports/phase2_mc_state_modes_smoke_report.md)
	- [x] `v+spike+u+r+eff` を `proj_out_dim=0/100/200` でrepeats5評価（圧縮の劣化確認）
		- レポート: [outputs/phase2/mc/reports/phase2_mc_state_mode_project_repeats5_report.md](../../outputs/phase2/mc/reports/phase2_mc_state_mode_project_repeats5_report.md)
	- [x] 複数state_mode×投影（0/100/200）を repeats5 で比較（圧縮に強いstate_modeの選定）
		- レポート: [outputs/phase2/mc/reports/phase2_mc_state_modes_project_repeats5_report.md](../../outputs/phase2/mc/reports/phase2_mc_state_modes_project_repeats5_report.md)
		- ざっくり結論（n=120/steps=3000/max_delay=120）:
			- 投影なし（0）なら `v+spike+u+r+eff` が最強（mean MC≈28.99）
			- `proj_out_dim=200` で圧縮するなら `v+spike` が最も良い（mean MC≈16.31）
			- `proj_out_dim=100` はどのstate_modeでも大きく落ちる（mean MC≈7–8）
	- [x] 参考: `--state-zscore` を試したが、full（proj_out_dim=0）のばらつきが大きく今回は採用しない
		- レポート: [outputs/phase2/mc/reports/phase2_mc_state_mode_project_zscore_repeats5_report.md](../../outputs/phase2/mc/reports/phase2_mc_state_mode_project_zscore_repeats5_report.md)
	- [x] 採用する `state_mode`（必要なら `proj_out_dim`）を決定して、手順書/仕様書へ反映
		- 結論: 軽さ優先の標準案は **`state_mode=v+spike` + `proj_out_dim=200`**。

### Step 2.4: オンライン学習（RLS）（仕様書 Step 2.4）
環境やユーザーの変化に合わせてReadoutを更新できるようにする段階です。安定に学習できる更新設計（間引かない/発散しない）がポイントです。
- [x] RLSコア実装（忘却係数 lambda + Tikhonov正則化 delta）（`sorch/core/rls.py`）
- [x] オンライン学習ベンチ雛形（RLSでreadout更新し、遅延ごとのR^2を出す）（`sorch/bench/rls_online.py`）
- [x] オンライン学習ベンチ（ReadoutをRLSで更新し、遅延/安定性を確認）
	- レポート: [outputs/phase2/rls/reports/phase2_rls_online_repeats5_v3_report.md](../../outputs/phase2/rls/reports/phase2_rls_online_repeats5_v3_report.md)

- [x] 更新間隔（10–50ms）での安定動作（発散しない／性能が維持できる）
	- 結果: `update_every=10/20/50`（10–50ms相当）でも `mc_online` が安定して正に出ることを確認。
	- レポート: [outputs/phase2/rls/reports/phase2_rls_online_block_sweep_repeats5_report.md](../../outputs/phase2/rls/reports/phase2_rls_online_block_sweep_repeats5_report.md)

- [x] `lam<1`（忘却あり）のsweep（推奨値の決定）
	- レポート: [outputs/phase2/rls/reports/phase2_rls_online_block_lam_sweep_repeats5_report.md](../../outputs/phase2/rls/reports/phase2_rls_online_block_lam_sweep_repeats5_report.md)
	- 結論（今回のベンチ設定）: `lam=0.999` は動作するがMCが低下、`lam<=0.995` は重みノルムが増大して `mc_online=0` に崩れやすい → ベンチ用途の推奨は `lam=1.0`（忘却を入れるなら `0.999` から）

---

## Phase 3: システム統合と非同期制御
実運用に向けて「耳（Audio）」「脳（Core）」「思考（Cognitive）」「口（Motor）」を並列化し、止める信号を最優先で通す仕組みを作るフェーズです。

### ドキュメント更新（Phase 3）
Phase 3は構成が複雑になりやすいので、設計の前提と起動/検証手順を丁寧に残します。
- [ ] 行う作業についての手順書を作成
- [x] 作成したコマンド/オプションを [docs/ガイド.md](../%E3%82%AC%E3%82%A4%E3%83%89.md) の「すぐ動かす」「コマンド」節に追加
- [ ] 行った作業の成果を [docs/project/成果サマリ.md](../project/%E6%88%90%E6%9E%9C%E3%82%B5%E3%83%9E%E3%83%AA.md) に反映
- [ ] ベンチマーク等を行ったら、結果レポートを outputs に保存

### Step 3.1: 運動野の表現力（Speech Plan / プロソディ / Revision）（仕様書 Step 3.1）
テキストだけでなく「話し方（抑揚・間・強調）」や「付け足し/言い直し」を扱えるようにする段階です。
Orchestratorの学習を複雑にしすぎないため、話し方の詳細はMotor側の実装に寄せ、Orchestratorは低次元の指示（Speech Plan）だけ出します。

- [ ] Speech Plan のスキーマを決める（Orchestrator→Motorの契約）
	- 例: `text`, `intent`, `delivery`, `revision_policy`
	- 用語: Speech Plan（[用語集](%E7%94%A8%E8%AA%9E%E9%9B%86.md#glossary-speech-plan)）
- [ ] Motor Cortex側で Speech Plan → TTSパラメータのマッピングを実装
	- 用語: プロソディ（[用語集](%E7%94%A8%E8%AA%9E%E9%9B%86.md#glossary-prosody)）
- [ ] チャンク再生キューの「追記/差し替え」戦略を実装（Revision対応）
	- 用語: Revision（[用語集](%E7%94%A8%E8%AA%9E%E9%9B%86.md#glossary-revision)）
- [ ] 仕様書（Motor Cortex / Speech Plan）とガイドの説明を同期
	- 仕様: [docs/spec/仕様書.md](../spec/%E4%BB%95%E6%A7%98%E6%9B%B8.md)
	- ガイド: [docs/ガイド.md](../%E3%82%AC%E3%82%A4%E3%83%89.md)

### Step 3.2: マルチプロセス・アーキテクチャの構築（仕様書 Step 3.2）
処理をプロセス分割して、リアルタイム性と堅牢性を上げる段階です（GIL回避、優先度制御の前提作り）。
- [ ] マルチプロセス設計（Audio/Core/Cognitive/Motor）
	- 状況: 最小のマルチプロセス骨格（dry-run〜実機I/O）を実装して検証済み。統合の拡張（Cognitive統合など）は継続。

- [ ] Core Executive（学習で能動判断する司令塔）のI/Oを定義
	- 例: `Cognitive_Request`（呼ぶ/呼ばない）、`Speech_Plan`（相槌/本返答）、`Interrupt_Action`（話し切り/譲る/待って）
- [ ] Motor → Core の状態フィードバックI/F（学習の観測）を定義
	- 例: 再生中フラグ、残チャンク/残り推定ms、重要度ラベル、中断コスト
- [ ] Soft Interrupt（割り込み兆候）のイベント定義（Hard Stopと分離）
	- 用語: Soft Interrupt（[用語集](%E7%94%A8%E8%AA%9E%E9%9B%86.md#glossary-soft-interrupt)）

### Step 3.3: Lock-free Queue による通信（仕様書 Step 3.3）
プロセス間通信の遅延と詰まりを減らす段階です。SPSC等の実装を選定し、ベンチで確認します。
- [x] Lock-free Ring Buffer (SPSC) 導入

### Step 3.4: 優先度付き制御ロジック（仕様書 Step 3.4）
Stop信号が来たら「他の処理より必ず先に止める」制御を入れる段階です。安全性を最優先します。
- [x] Hard Stop（安全停止）を物理レベルで最優先する制御

- [ ] Soft Interrupt（割り込み兆候）に対する割り込み方針を学習で最適化する
	- 例: 残りが短いなら話し切る／重要説明なら「ちょっと待って」／それ以外は譲る
	- 方針: ルールを増やすのではなく、観測（Motor状態/短期記憶/特徴量）とKPI（体験・安全）で学習させる

---

## Phase 4: UX向上と常駐化
使いやすさ（見える化/設定/常駐）を整えるフェーズです。挙動の理解とチューニングを、開発者以外でも回せる形にします。

### ドキュメント更新（Phase 4）
UX系は変更が頻繁になりがちなので、設定項目や画面/出力の見方が変わったら必ず同期します。
- [ ] UX/常駐まわりの仕様が変わったら [docs/spec/仕様書.md](../spec/%E4%BB%95%E6%A7%98%E6%9B%B8.md) の Step 4.x を更新
- [ ] Brain Visualizer の使い方/見方が変わったら [docs/ガイド.md](../%E3%82%AC%E3%82%A4%E3%83%89.md) に追記
- [ ] ユーザーが触る設定が増えたら [docs/project/用語集.md](%E7%94%A8%E8%AA%9E%E9%9B%86.md) に追記
- [ ] 新しい成果物（スクショ/デモ/使い方）が増えたら [docs/project/成果サマリ.md](%E6%88%90%E6%9E%9C%E3%82%B5%E3%83%9E%E3%83%AA.md) を更新
- [ ] ベンチマーク等を行ったら、結果レポートを outputs に保存

### Step 4.1: 脳波モニター（Brain Visualizer）（仕様書 Step 4.1）
内部状態（v/spike/effなど）を可視化して、デバッグと理解をしやすくする段階です。まずは最小の可視化から始めます。
- [ ] Brain Visualizer（デバッグ可視化）

### Step 4.2: 会話パラメータの感覚的チューニング（仕様書 Step 4.2）
パラメータ調整を「コード編集」ではなく「設定とUI」で回せるようにする段階です。再現性（保存/共有）を重視します。
- [ ] 会話パラメータのチューニングUI/設定管理
