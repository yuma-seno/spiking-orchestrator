# 作業一覧（チェックリスト）

このチェックリストは **作業の過程で随時追加・更新していく「生きたドキュメント」** です。
- 完了した項目はチェック済みにします。
- 対応中、およびスキップした項目は状況を項目の下にメモしておきます。
- 新しいタスクが見つかったら、このファイルに遠慮なく追記してOKです。

---

## 環境（事前準備）
- [x] Dev Container（python 3.12）で開発できる
- [x] 依存関係インストール（requirements）
- [x] 音声デバイス共有（/dev/snd）確認

## ドキュメント整備
- 出力場所やファイル名を変えたら [docs/ガイド.md](../%E3%82%AC%E3%82%A4%E3%83%89.md) と [README.md](../../README.md) のリンク整合を確認すること
- 仕様/挙動が変わったら [docs/spec/仕様書.md](../spec/%E4%BB%95%E6%A7%98%E6%9B%B8.md) を更新

## Phase 1: ベンチマークと反射回路の実装

### ドキュメント更新（Phase 1）
- [x] 行う作業についての手順書を作成
- [x] 作成したコマンド/オプションを [docs/ガイド.md](../%E3%82%AC%E3%82%A4%E3%83%89.md) の「すぐ動かす」「コマンド」節に追加
- [x] 行った作業の成果を [docs/project/成果サマリ.md](../project/%E6%88%90%E6%9E%9C%E3%82%B5%E3%83%9E%E3%83%AA.md) に反映
- [x] ベンチマーク等を行ったら、結果レポートを outputs に保存

### Step 1.0: 遅延計測ベンチマーク（仕様書 Step 1.0）
- [x] ベンチCLI実装（マイク→特徴量→判定→停止）
- [x] p50/p95/p99/std を算出できる
- [x] stopイベントを JSONL に保存できる
- [x] デバイス一覧/デバイス指定オプション追加（入力/出力 index）
- [x] ビープ対策（デフォルト無音出力）
- [x] 実機で計測実施（入力4/出力0）
- [x] 計測結果を保存（outputs配下）

### Step 1.1: Reflex Circuit プロトタイプ（暫定DSP → 将来SNNへ）（仕様書 Step 1.1）
- [x] 適応閾値（EMA）
- [x] 不感期（hold-off）
- [x] ループバック抑制フック（loopback_active）
- [x] ユニットテスト（Reflex/特徴量）
- [ ] Reflex Circuit をSNN版へ置換（SpikingJelly, 固定重み + 安全ロジック）
	- 状況: DSP版は動作・テスト済み。SNN版は未着手。
	- 次: 固定重みの最小SNN（入力=特徴量→出力=Stop）を作り、DSP版と差し替え可能にする
- [ ] SNN版Reflexで誤検知チューニング（咳払い/打音など）
	- 状況: チューニング手順/評価データ未整備。
	- 次: 誤検知ケース（咳払い/打音/環境音）を収集して、FP/FNの定量評価ループを作る

### Step 1.2: 停止制御（Hard Stop：TTS等を含む停止）（仕様書 Step 1.2）
- [ ] VOICEVOX等の実TTS再生キューのクリア
	- 状況: TTS統合前提のため未着手。
	- 次: 実TTSの再生/キューAPIを洗い出して「即時クリア」を最優先で実装
- [ ] オーディオデバイスのリセット（APIレベルでプリエンプティブ確認）
	- 状況: OS/ドライバ依存のため要実機検証。
	- 次: Linux（ALSA/JACK）で再生停止のプリエンプティブ性（最悪p99）を測る
- [ ] 停止のエンドツーエンド測定（TTSを含む）
	- 状況: Step 1.0 はベンチで達成済み、TTS込みは未。
	- 次: TTSチャンク再生を繋いで、Stop→再生停止のp95/p99を記録

---

## Phase 2: 記憶回路と文脈制御

### ドキュメント更新（Phase 2）
- [x] 行う作業についての手順書を作成
- [x] 作成したコマンド/オプションを [docs/ガイド.md](../%E3%82%AC%E3%82%A4%E3%83%89.md) の「すぐ動かす」「コマンド」節に追加
	- 状況: Phase 2 の主要コマンド（MC探索/状態比較/RLS）と推奨オプションを反映済み。
- [x] 行った作業の成果を [docs/project/成果サマリ.md](../project/%E6%88%90%E6%9E%9C%E3%82%B5%E3%83%9E%E3%83%AA.md) に反映
- [x] ベンチマーク等を行ったら、結果レポートを outputs/phase2/ 配下に保存

### Step 2.1: STPニューロン（仕様書 Step 2.1）
- [x] `STP_LIFNode` 実装（Tsodyks–Markram）
- [x] ユニットテスト追加

### Step 2.2: MC探索（仕様書 Step 2.2）
- [x] 500〜1000ニューロンのリザーバ構築
- [x] 入力パターン生成（ランダム/疑似会話テンポ）
- [x] MCスコア計測（過去入力の復元）
- [x] 探索パラメータ sweep（tau_F/tau_D/W_scale）
- [x] 結果をCSV/JSONで保存
- [x] MC探索スクリプトの手順書を整備
- [x] MCグリッド探索（複数条件を一括実行）
- [x] MC 2段階探索（粗→細、自動リファイン）
- [x] MC結果の集計（Top候補レポート生成）
- [x] `convo` 入力で発火が出ないケースのガード（`spike_rate=0` の WARNING 追加）
- [x] 発火を出しやすい `convo_spiking` プリセット追加（`v_threshold=0.25`, `dc_bias=0.25` 自動セット）

### Step 2.3: Readout / 次元削減（仕様書 Step 2.3）
- [x] Random Projection実装
- [x] `mc_report` が `proj_out_dim` を理解してレポート化できるよう拡張（投影次元=out_dim）
- [x] `mc_project` を repeats（複数seed）で実行し、proj_out_dim ごとのMC劣化をレポート化（convo_spiking基準）
	- レポート: [outputs/phase2/mc/reports/phase2_mc_project_convo_spiking_repeats5_report.md](../../outputs/phase2/mc/reports/phase2_mc_project_convo_spiking_repeats5_report.md)
- [x] 「採用できる最小 proj_out_dim」の目安を決める（例: fullの90%維持、など）
	- repeats5（n=120/steps=3000）の目安: proj_out_dim=200 はほぼ full、proj_out_dim=100 は約83%程度、50/25 は大きく劣化
	- 暫定結論: 90%維持を狙うなら proj_out_dim=200 を基本（より攻めるなら 100 も候補）

- [x] Readoutが参照する状態ベクトル設計（どの信号を含めるか）
	- 状況: 比較ベンチ/レポートまで完了。残りは「採用案の確定」と「ドキュメントへの明記」。
	- 次: `proj_out_dim=200` 前提で `state_mode=v+spike` をデフォルト方針として確定し、仕様書/手順/ガイドに明記
	- [x] STPリザーバの内部状態トレース取得（`run_traces`: v/spike/u/r/eff）
		- v/spike: ニューロンの状態（膜電位/発火）
		- u/r/eff: STPの内部状態（[用語: STP](%E7%94%A8%E8%AA%9E%E9%9B%86.md#glossary-stp)）
	- [x] `mc_project` に `--state-modes` を追加し、`state_mode/state_dim` をCSVへ保存（[用語: state_mode](%E7%94%A8%E8%AA%9E%E9%9B%86.md#glossary-state-mode)）
	- [x] `mc_report` が `state_mode/state_dim` を表示できるよう拡張
	- [x] state_mode 比較を repeats5 で実行してレポート化（convo_spiking基準）
		- レポート: [outputs/phase2/mc/reports/phase2_mc_state_modes_smoke_report.md](../../outputs/phase2/mc/reports/phase2_mc_state_modes_smoke_report.md)
	- [x] `v+spike+u+r+eff` を `proj_out_dim=0/100/200` でrepeats5評価（圧縮の劣化確認）
		- レポート: [outputs/phase2/mc/reports/phase2_mc_state_mode_project_repeats5_report.md](../../outputs/phase2/mc/reports/phase2_mc_state_mode_project_repeats5_report.md)
	- [x] 複数state_mode×投影（0/100/200）を repeats5 で比較（圧縮に強いstate_modeの選定）
		- レポート: [outputs/phase2/mc/reports/phase2_mc_state_modes_project_repeats5_report.md](../../outputs/phase2/mc/reports/phase2_mc_state_modes_project_repeats5_report.md)
		- ざっくり結論（n=120/steps=3000/max_delay=120）:
			- 投影なし（0）なら `v+spike+u+r+eff` が最強（mean MC≈28.99）
			- `proj_out_dim=200` で圧縮するなら `v+spike` が最も良い（mean MC≈16.31）
			- `proj_out_dim=100` はどのstate_modeでも大きく落ちる（mean MC≈7–8）
	- [x] 参考: `--state-zscore` を試したが、full（proj_out_dim=0）のばらつきが大きく今回は採用しない
		- レポート: [outputs/phase2/mc/reports/phase2_mc_state_mode_project_zscore_repeats5_report.md](../../outputs/phase2/mc/reports/phase2_mc_state_mode_project_zscore_repeats5_report.md)
	- [x] 採用する `state_mode`（必要なら `proj_out_dim`）を決定して、手順書/仕様書へ反映
		- 状況: repeats5の結果は揃っており、軽さ優先の現実案は **`state_mode=v+spike` + `proj_out_dim=200`**。
		- 次: これを「Phase2の標準設定」として明記し、今後のベンチはこの設定を基本にする（反映済み）

### Step 2.4: オンライン学習（RLS）（仕様書 Step 2.4）
- [x] RLSコア実装（忘却係数 lambda + Tikhonov正則化 delta）（`sorch/core/rls.py`）
- [x] オンライン学習ベンチ雛形（RLSでreadout更新し、遅延ごとのR^2を出す）（`sorch/bench/rls_online.py`）
	- 状況: **評価の取り方を修正して `mc_online=0` 張り付きを解消**（最終重みでin-sample評価）。
	- 次: repeats→レポート→結論を反映し、Step 2.4の完了条件を明確化する
- [x] オンライン学習ベンチ（ReadoutをRLSで更新し、遅延/安定性を確認）
	- 状況: `state_mode=v+spike` + `proj_out_dim=200` でrepeats5を実施し、MCが正に出ることを確認。
		- レポート: [outputs/phase2/rls/reports/phase2_rls_online_repeats5_v3_report.md](../../outputs/phase2/rls/reports/phase2_rls_online_repeats5_v3_report.md)
	- 次: 「Phase2の標準設定」との整合（Step 2.3の採用案）を明記し、以後のオンライン学習は同設定を基本にする

- [x] 更新間隔（10–50ms）での安定動作（発散しない／性能が維持できる）
	- 状況: **ブロック更新（`--update-mode block`）を導入して解決**。
		- `update_every=10/20/50`（10–50ms相当）でも、`mc_online` が安定して正に出ることを確認。
		- レポート: [outputs/phase2/rls/reports/phase2_rls_online_block_sweep_repeats5_report.md](../../outputs/phase2/rls/reports/phase2_rls_online_block_sweep_repeats5_report.md)
	- 次: `lam<1`（忘却あり）での推奨値を決める（MCベンチでは安定性/性能が維持できる範囲を確認）

- [x] `lam<1`（忘却あり）のsweep（推奨値の決定）
	- 状況: `update_mode=block, update_every=10, delta=0.01` で `lam={1.0, 0.999, 0.995, 0.99}` をrepeats5評価。
		- レポート: [outputs/phase2/rls/reports/phase2_rls_online_block_lam_sweep_repeats5_report.md](../../outputs/phase2/rls/reports/phase2_rls_online_block_lam_sweep_repeats5_report.md)
	- 結論（今回のベンチ設定）: `lam=0.999` は動作するがMCが低下、`lam<=0.995` は重みノルムが増大して `mc_online=0` に崩れやすい → ベンチ用途の推奨は `lam=1.0`（忘却を入れるなら `0.999` から）

---

## Phase 3: システム統合と非同期制御
### ドキュメント更新（Phase 3）
- [ ] 行う作業についての手順書を作成
- [ ] 作成したコマンド/オプションを [docs/ガイド.md](../%E3%82%AC%E3%82%A4%E3%83%89.md) の「すぐ動かす」「コマンド」節に追加
- [ ] 行った作業の成果を [docs/project/成果サマリ.md](../project/%E6%88%90%E6%9E%9C%E3%82%B5%E3%83%9E%E3%83%AA.md) に反映
- [ ] ベンチマーク等を行ったら、結果レポートを outputs に保存

### Step 3.1: マルチプロセス・アーキテクチャの構築（仕様書 Step 3.1）
- [ ] マルチプロセス設計（Audio/Core/Cognitive）
	- 状況: まだ単一プロセス前提。
	- 次: Audio/Core/Cognitive の責務と境界（共有データ/メッセージ）を設計して最小プロトタイプを作る

### Step 3.2: Lock-free Queue による通信（仕様書 Step 3.2）
- [ ] Lock-free Ring Buffer (SPSC) 導入
	- 状況: IPC方式未選定。
	- 次: 想定スループット（1ms tick）で詰まらないSPSCを選定し、遅延計測ベンチを用意

### Step 3.3: 優先度付き制御ロジック（仕様書 Step 3.3）
- [ ] Stop信号を物理レベルで最優先する制御
	- 状況: Stop優先のE2E統合が未。
	- 次: Motor側の最優先経路（キュー破棄/デバイスリセット）を、他処理に割り込んで実行できる形にする

---

## Phase 4: UX向上と常駐化

### ドキュメント更新（Phase 4）
- [ ] UX/常駐まわりの仕様が変わったら [docs/spec/仕様書.md](../spec/%E4%BB%95%E6%A7%98%E6%9B%B8.md) の Step 4.x を更新
- [ ] Brain Visualizer の使い方/見方が変わったら [docs/ガイド.md](../%E3%82%AC%E3%82%A4%E3%83%89.md) に追記
- [ ] ユーザーが触る設定が増えたら [docs/project/用語集.md](%E7%94%A8%E8%AA%9E%E9%9B%86.md) に追記
- [ ] 新しい成果物（スクショ/デモ/使い方）が増えたら [docs/project/成果サマリ.md](%E6%88%90%E6%9E%9C%E3%82%B5%E3%83%9E%E3%83%AA.md) を更新
- [ ] ベンチマーク等を行ったら、結果レポートを outputs に保存

### Step 4.1: 脳波モニター（Brain Visualizer）（仕様書 Step 4.1）
- [ ] Brain Visualizer（デバッグ可視化）
	- 状況: 可視化対象（v/spike/eff等）と出力形（GUI/CSV/Web）が未決。
	- 次: Phase 2 の state_mode で扱う信号を最小セットとして可視化（まずはオフラインプロット）

### Step 4.2: 会話パラメータの感覚的チューニング（仕様書 Step 4.2）
- [ ] 会話パラメータのチューニングUI/設定管理
	- 状況: 変更したいパラメータ一覧が未整理。
	- 次: まずは `state_mode/proj_out_dim/lam/delta` を設定ファイル化し、CLIと同期する
