# 成果サマリ

この文書は、SORCHが「何を目指して」「何をやって」「どんな結果が出て」「それが目的に対してどういう成果か」を、**Phase/Step単位**で追えるようにまとめたものです。

- 入口（まずここ）: [docs/ガイド.md](../%E3%82%AC%E3%82%A4%E3%83%89.md)
- ゴール/KPI（評価基準）: [docs/spec/仕様書.md](../spec/%E4%BB%95%E6%A7%98%E6%9B%B8.md)
- 用語がつらいとき: [docs/project/用語集.md](%E7%94%A8%E8%AA%9E%E9%9B%86.md)

---

## 0. いま何ができる？（超短縮）

| 目的 | いま出来ていること | 根拠（成果物） |
|:--|:--|:--|
| 「止める」を数字で管理したい | Stop遅延（ソフト側）をp95/p99まで測れて、p99 < 1msを確認 | [outputs/phase1/report/Phase1_測定結果.md](../../outputs/phase1/report/Phase1_%E6%B8%AC%E5%AE%9A%E7%B5%90%E6%9E%9C.md) |
| 「短期記憶」を作りたい | STP付きリザーバを作り、MC探索（sweep/refine）で比較できる | [outputs/phase2/mc/reports/](../../outputs/phase2/mc/reports/) |
| 「軽くて実用的な状態ベクトル」を決めたい | `state_mode=v+spike` + `proj_out_dim=200` をPhase2の標準案として採用できる材料が揃った | [outputs/phase2/mc/reports/phase2_mc_state_modes_project_repeats5_report.md](../../outputs/phase2/mc/reports/phase2_mc_state_modes_project_repeats5_report.md) |
| 「オンライン学習（RLS）」を動かしたい | RLS更新を回して delay別R² を出し、repeats→レポート化まで一通り動く（忘却係数 `lam` の推奨目安も確認） | [outputs/phase2/rls/reports/phase2_rls_online_repeats5_v3_report.md](../../outputs/phase2/rls/reports/phase2_rls_online_repeats5_v3_report.md) / [outputs/phase2/rls/reports/phase2_rls_online_block_lam_sweep_repeats5_report.md](../../outputs/phase2/rls/reports/phase2_rls_online_block_lam_sweep_repeats5_report.md) |
| 「10–50ms更新でも維持したい」 | ブロック更新で `update_every=10/20/50` を実現し、性能が維持されることを確認 | [outputs/phase2/rls/reports/phase2_rls_online_block_sweep_repeats5_report.md](../../outputs/phase2/rls/reports/phase2_rls_online_block_sweep_repeats5_report.md) |
| 「安全を崩さず表現力を上げたい」 | Reflex/Reservoirは“概念的領域分割”を守れば単一SNN統合も可能、ただしHard Stopは独立最優先経路で保護する方針を確立 | 仕様: [docs/spec/仕様書.md](../spec/%E4%BB%95%E6%A7%98%E6%9B%B8.md) / 用語: [docs/project/用語集.md](%E7%94%A8%E8%AA%9E%E9%9B%86.md) |

将来目標（マルチモーダル出力）:
- 出力を音声だけに限定せず、マウス/キーボード/ロボット操作なども含めて扱う。
- Action Plan（任意テキスト + 低次元制御ベクトル）を核にし、「上位の実行制御は統合」「下位のデバイス制御はDriverとして分離」する。

---

## 1. 評価指標（KPI）を先に理解する

仕様書では「体感の良さ」を、主に **遅延（Latency）** と **記憶性能（MC）** として数値管理します。

### 1.1 Stop遅延（Latency）

- 測りたいもの: 「止める」と判断してから停止命令が出るまでの処理時間（まずはソフト側）
- 代表値:
  - Median（中央値）: 真ん中の値
  - p95 / p99: 上位5% / 1% の“遅い側”の値（体験のばらつき＝テールを観る）

### 1.2 Memory Capacity（MC）

MCは「**今のリザーバ状態 $x(t)$ を見れば、少し前の入力 $u(t-k)$ をどれだけ復元できるか**」の点数です。

#### (a) まず $R^2$（決定係数）

$$R^2 = 1 - \frac{\mathrm{MSE}(y, \hat{y})}{\mathrm{Var}(y)}$$

- $R^2=1$: 完璧に当たる
- $R^2=0$: 平均を出すのと同じ程度（当たっていない）
- $R^2<0$: 平均よりも悪い（外している）

#### (b) MC（複数の遅延を合計）

遅延 $k$ ごとに $R^2_k$ を出し、足し合わせます（本プロジェクトでは負の$R^2$は0扱い）。

$$\mathrm{MC} = \sum_{k=1}^{K} \max(0, R^2_k)$$

---

## 2. Phase 1: ベンチマークと反射回路の実装

**目的（仕様書）:** エンドツーエンド遅延の実測と、誤検知のない割り込み停止の土台づくり。

### Step 1.0: 遅延計測ベンチマーク（Must Do First）

#### 目的

- 仕様書のKPI（Median < 50ms、p99 < 100ms）に対して、まず「測れる」ようにする
- どこが遅延の主因なのかを切り分ける

#### やったこと

- 「マイク入力 → 特徴量 → 判定 → stop相当処理」を測るベンチを実装
- 安全のため **無音出力モード**をデフォルトにし、誤って音を鳴らし続けない設計
- 実機で計測し、サマリレポートを出力

#### 出た結果（数字）

Phase 1の実測サマリにまとまっています:

- レポート: [outputs/phase1/report/Phase1_測定結果.md](../../outputs/phase1/report/Phase1_%E6%B8%AC%E5%AE%9A%E7%B5%90%E6%9E%9C.md)

例（frames=128の測定）:

| 指標 | 値 |
|---:|:---|
| Median | 0.24 ms |
| p95 | 0.38 ms |
| p99 | 0.39 ms |

#### この結果は何が“成果”？（目的に対する意味）

- **ソフト側のStop処理はボトルネックではない**（sub-ms）ことが確認できた
- 次にやるべきは「OS/ドライバのバッファ」や「TTS再生キュー」など、**エンドツーエンド要素**の測定と最適化

> 補足: 仕様書には `outputs/phase1/latency/` にJSONLを保存する想定がありますが、現状このリポジトリにはサマリのみが残っています（運用方針によりログをGit管理しない可能性があるため）。

### Step 1.1: Reflex Circuit プロトタイプ（暫定DSP）

#### 目的

- “止める”の判断を、誤検知を抑えつつ即時に出せるようにする

#### やったこと

- 適応閾値（EMA）・不感期（hold-off）・ループバック抑制フックなど、誤検知対策の骨格を追加
- ユニットテストを整備し、「壊れていない」を継続的に確認できる形にした

#### 出た結果

- Reflexの安全ロジックを実装し、テストで検証できる状態になった

#### この結果は何が“成果”？

- 「安全停止」という最重要機能を、まずはDSPで**確実に動く土台**として用意できた
- 次はこれをSNN版へ置換しても安全性を維持できるか、という段階に進める

### Step 1.2: 停止制御（Hard Stop）

#### 目的

- TTS等を含めた“本当の停止”を、即時に実行できるようにする

#### 現状

- 実装/実測はこれから（キュー破棄・デバイスリセットなど）

---

## 3. Phase 2: 記憶回路と文脈制御

**目的（仕様書）:** 会話の「間」と「テンポ」を、STP付きリザーバ（短期記憶）として実装し、評価できるようにする。

### Step 2.1: STPニューロンの実装

#### 目的

- Tsodyks–MarkramのSTPを、リザーバの内部状態として持てるようにする

#### やったこと

- STP付きのリザーバを実装し、テストで動作の最低保証を作った

#### 出た結果 / 成果

- STPの内部状態（例: $u,r,eff$）も含めた設計検討ができるようになり、Step 2.3の比較に進めた

### Step 2.2: MC探索（Memory Capacityの最大化）

#### 目的

- STPパラメータや結合強度を振って、短期記憶（MC）が上がる条件を探す

#### やったこと

- 入力生成（ランダム/疑似会話テンポ）と、MC評価の仕組みを整備
- sweep（網羅）→ refine（粗→細）→ report（集計）の流れを確立

#### 出た結果（代表）

- 大きめの探索例（上位候補の一覧）: [outputs/phase2/mc/reports/phase2_mc_refine_large_report.md](../../outputs/phase2/mc/reports/phase2_mc_refine_large_report.md)

#### この結果は何が“成果”？

- 「STPの設定でMCが変わる」ことを、主観ではなく **CSV＋集計レポート**で比較できるようになった
- 次のStep 2.3（状態ベクトル設計）に対して、同一の評価基盤を流用できる

### Step 2.3: Readout / 次元削減（状態ベクトル設計）

#### 目的

- Readoutに渡す情報（状態ベクトル）を決める
- 重さ（次元）と性能（MC）のトレードオフを、Random Projection込みで決める

#### やったこと（やるべき比較を全部、再現可能な形で実施）

- Random Projection（投影）を導入し、`proj_out_dim` を振って劣化を測れるようにした
- `state_mode` を切り替えて、膜電位だけでなく spike や STP内部状態も比較できるようにした
- repeats（seed=0..4）で“たまたま良かった”を排除し、レポートで判断材料を固定した

#### 出た結果（結論が一目で分かる表）

前提（共通条件の例）: n=120, steps=3000, washout=300, max_delay=120, convo_spiking

| 何を決めたい？ | 代表結果 | 意味（成果） | 根拠 |
|:--|:--|:--|:--|
| 投影しても性能を落としすぎない次元は？ | `proj_out_dim=200` はほぼfull、`100` は明確に劣化 | “軽さ”の下限を数値で決められる | [outputs/phase2/mc/reports/phase2_mc_project_convo_spiking_repeats5_report.md](../../outputs/phase2/mc/reports/phase2_mc_project_convo_spiking_repeats5_report.md) |
| 状態に何を含めると強い？（投影なし） | `v+spike+u+r+eff` が最強（mean MC≈28.99） | STP内部状態が効くことを確認 | [outputs/phase2/mc/reports/phase2_mc_state_modes_project_repeats5_report.md](../../outputs/phase2/mc/reports/phase2_mc_state_modes_project_repeats5_report.md) |
| 状態に何を含めると強い？（投影あり200） | `v+spike` が最良（mean MC≈16.31） | 圧縮下では情報の相性が変わる | 同上 |

#### 採用案（Phase 2の標準設定）

軽さ優先の現実案として、以後のPhase 2ベンチは基本この条件で進めます:

- **`state_mode=v+spike` + `proj_out_dim=200`**

理由（初心者向けに言うと）:

- 「本当は情報をたくさん入れるほど当たりやすい」
- でも「入れすぎると重い」
- そこで **“投影しても崩れにくい情報セット”**として `v+spike` を採用する、という意思決定

### Step 2.4: オンライン学習（RLS）

#### 目的

- Readout重みをオンラインで更新し、ユーザーや状況の変化に追従できるようにする

#### やったこと

- RLS（Recursive Least Squares）を実装し、ベンチで回せるようにした
- repeats→集計レポートまで自動化し、**「安定しているか」を数値で判断**できるようにした

参考：RLSの基本更新式（概念）

$$k_t = \frac{P_{t-1}x_t}{\lambda + x_t^\top P_{t-1}x_t}$$
$$W_t = W_{t-1} + k_t (y_t - x_t^\top W_{t-1})$$
$$P_t = \frac{1}{\lambda}\left(P_{t-1} - k_t x_t^\top P_{t-1}\right)$$

#### 出た結果（repeats5）

- レポート: [outputs/phase2/rls/reports/phase2_rls_online_repeats5_v3_report.md](../../outputs/phase2/rls/reports/phase2_rls_online_repeats5_v3_report.md)

要点:

- ベースライン（毎ステップ更新）:
  - `state_mode=v+spike`, `proj_out_dim=200`, `update_every=1`, `lam=1`, `delta=0.01`
  - mean `mc_online` ≈ 1.086（seed=0..4）
  - delay別R²も正に出る（例: delay=1でR²≈0.21）

- **更新間隔を落としても維持（10–50ms相当）**:
  - `--update-mode block`（サンプルを捨てずにまとめて更新）を導入
  - `update_every=10/20/50` でも `mc_online` が同等に維持されることを確認
  - レポート: [outputs/phase2/rls/reports/phase2_rls_online_block_sweep_repeats5_report.md](../../outputs/phase2/rls/reports/phase2_rls_online_block_sweep_repeats5_report.md)

- **忘却係数（`lam<1`）の推奨目安（今回のベンチ設定）**:
  - `lam=0.999` は動作するが、`lam=1.0` より `mc_online` が下がる
  - `lam<=0.995` は重みノルムが増大して `mc_online=0` に崩れやすい
  - 推奨: ベンチ用途は `lam=1.0`（忘却を入れるなら `0.999` から）
  - レポート: [outputs/phase2/rls/reports/phase2_rls_online_block_lam_sweep_repeats5_report.md](../../outputs/phase2/rls/reports/phase2_rls_online_block_lam_sweep_repeats5_report.md)

#### この結果は何が“成果”？

- 「オンライン学習が動いているか」を、**R²とレポートで確認できる土台**ができた
- さらに、**実運用を意識した更新間隔（10–50ms相当）でも性能を維持できる更新設計（ブロック更新）**が入った
- 「忘却あり（`lam<1`）の挙動」を、レポート付きで再現可能な形にできた（推奨値の目安ができた）

---

## 4. つぎに重要な課題（何をやると“完成に近づく”か）

| 重要課題 | なぜ重要？ | 次のアクション |
|:--|:--|:--|
| Step 1.2（TTSを含むHard Stopの実測） | “体感の停止”はTTS/バッファが支配しやすい | TTSキュー破棄＋デバイス停止を実装し、E2Eをp99で測る |
| Step 2.4（10–50ms更新でも安定するRLS） | 実運用では毎ms更新は重い可能性 | ブロック更新/特徴量設計/正則化の見直しを追加ベンチで検証 |
| Step 1.1（ReflexのSNN置換） | 将来の統合でSNNに寄せる必要 | DSPと同等の安全ロジックを維持した最小SNNを作る |

---

## 5. 迷子にならない読み順（初心者向け）

1. [docs/ガイド.md](../%E3%82%AC%E3%82%A4%E3%83%89.md)
2. [docs/spec/仕様書.md](../spec/%E4%BB%95%E6%A7%98%E6%9B%B8.md)
3. Phase 1の結果: [outputs/phase1/report/Phase1_測定結果.md](../../outputs/phase1/report/Phase1_%E6%B8%AC%E5%AE%9A%E7%B5%90%E6%9E%9C.md)
4. Phase 2の結論:
   - 投影の劣化: [outputs/phase2/mc/reports/phase2_mc_project_convo_spiking_repeats5_report.md](../../outputs/phase2/mc/reports/phase2_mc_project_convo_spiking_repeats5_report.md)
   - 状態ベクトル: [outputs/phase2/mc/reports/phase2_mc_state_modes_project_repeats5_report.md](../../outputs/phase2/mc/reports/phase2_mc_state_modes_project_repeats5_report.md)
   - RLSオンライン: [outputs/phase2/rls/reports/phase2_rls_online_repeats5_v3_report.md](../../outputs/phase2/rls/reports/phase2_rls_online_repeats5_v3_report.md)
