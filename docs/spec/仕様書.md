# Spiking Orchestrator (SORCH): SNN駆動型・自律対話エージェント 仕様書

この文書は、SORCH の仕様の「正（single source of truth）」です。
目的は“文章生成”ではなく、**会話の間（ま）・テンポ・割り込み**を、**実測レイテンシ**と**安全停止**で担保しながら成立させることです。

---

## 1. ゴールと非ゴール

### 1.1 ゴール（最重要）
- **停止の体験品質**を数値で管理する
  - publish→無音化 / publish→物理停止（close相当）を分けて計測し、p95/p99を常に見る
- **Hard Stop（安全停止）**を学習に依存させず、常に最優先で成立させる
- **単一SNN（Unified Core SNN）**に意思決定を統合し、出力は **Actuation Drivers** が実行する
- 将来のマルチモーダル（音声/マウス/キーボード/ロボット等）でも、Core→DriverのI/Oを増やさず運用する

### 1.2 非ゴール（この仕様書では扱わない）
- 生成モデル（LLM/RWKV等）そのものの学習・蒸留・最適化
- 具体TTSエンジンの選定・音質チューニング（Driver実装の裁量）
- 「安全停止」をSNNの判断に統合して一経路化すること（安全のため非推奨）

---

## 2. 設計原則

### 2.1 Tools と Core の分離（Bi-Level Architecture）
- **Tools**: 既製モデル/API（例: 音声認識、LLM、TTS）。交換可能。
- **Core**: SORCH本体（軽量SNN + 制御）。リアルタイム性と安全性に責任を持つ。

### 2.2 安全と体験を分離する（Hard Stop と Soft Interrupt）
- **Hard Stop**: 最優先・別経路。通常通信や学習の失敗をバイパスして止める。
- **Soft Interrupt**: 「止めろ命令」ではなく、Coreが「譲る/話し切る/待つ/短い返答」等を選ぶための観測入力。

### 2.3 Core→Driver のI/Oを増やさない
- Core→Driverの契約は原則として **任意テキスト + 低次元ベクトル**に集約する。
- マッピング詳細（音声の話し方、デバイス制御の細部）はDriver内部に押し込める。

---

## 3. システム全体像

### 3.1 モジュール（概念）
| レイヤー | モジュール | 役割 |
|---|---|---|
| 感覚 | Sensory（例: Audio） | マイク入力→特徴量化（低遅延）。割り込み兆候の抽出。 |
| 中枢 | Unified Core SNN | Reflex/Reservoir/Executive/出力制御を1つのSNNとして統合（概念的領域分割は保持）。 |
| 思考 | Cognitive Engine（Tool） | 必要なときだけ呼ぶ（重い推論）。 |
| 出力 | Actuation Drivers | Coreの出力チャネル（発火）のreadoutを受け、API呼び出しで実デバイスを駆動。Hard Stopを最優先で実行。 |

### 3.2 プロセス（推奨）
- Sensory Process（高優先度）
- Core Process（Unified Core SNN）
- Cognitive Process（Tool実行）
- Actuation Process（Drivers / キュー / Hard Stop）

---

## 4. 信号とインターフェース

### 4.1 Hard Stop 信号
- 名称: `Hard_Stop_Signal`
- 意味: Actuation Processは**最優先**で出力を停止する（無音化→キュー破棄→物理停止）。
- 経路: **最優先・別経路**（例: 共有メモリのフラグ）。通常経路の混雑を待たない。

### 4.2 Soft Interrupt（割り込み兆候）
- 名称: `Interrupt_Cue`
- 意味: Coreが行動選択をするための観測（止める命令ではない）
- 例: ユーザ発話開始、音圧上昇、VADイベント等

### 4.3 Core→Tool（Cognitive）
- 名称: `Cognitive_Request`
- 意味: Tool呼び出しを行う/行わない（あるいは軽い問い合わせだけ行う）

### 4.4 Core→Driver（Action Plan）
Core→Driver の唯一の“通常出力契約”。Driverはこれを解釈して実行する。

#### Action Plan（概念）
- `text`: 任意（空文字可）
- `u`: 低次元制御ベクトル $u(t) \in \mathbb{R}^K$（Kは小さく固定）

#### K の目安
- 3〜8 を目安に固定（増やさない）

#### 取り出し（実装の許容）
- Action Planは「SNN出力チャネル群の発火（レート/カウント等）をreadoutしたもの」として実装してよい。
- `text` の生成源はToolでもCoreでもよい（ただし“契約”としてはAction Planに集約する）。

---

## 5. Unified Core SNN 仕様（概念）

### 5.1 役割
Coreは以下を能動的に選択する。
- Toolをいつ呼ぶか（Fast Path / Tool Path）
- Driverへいつ何を出すか（Action Plan）
- 割り込み兆候にどう応じるか（譲る/話し切る/待つ/短い返答 等）

### 5.2 概念的領域分割（同一SNN内）
単一SNN内部に、概念的に以下の領域を持つ（実装は同一ネットワーク内のサブ集団で良い）。

- 領域A: Reflex（安全・低遅延）
  - 役割: 危険/停止要求を検知し、Hard Stopを発火
  - 方針: 原則固定（学習で壊さない）
  - 出力: `Hard_Stop_Signal`, `Interrupt_Cue`

- 領域B: Reservoir（短期文脈）
  - 役割: 会話テンポ、直近状態、待ち状態などの短期文脈を保持
  - 方針: STP等で状態が自然に変化

- 領域C: Executive（行動選択）
  - 役割: 観測から行動選択を学習で最適化
  - 出力: `Cognitive_Request`, `Action_Plan`

重要:
- Reflex/Reservoir/Executive を単一SNNに統合しても、**Hard Stopだけは別経路でDriverへ**。

---

## 6. Actuation Drivers 仕様

### 6.1 目的
Driverは行動を **安全に・即時に・途切れず** 実行する。
意思決定はCoreに寄せ、Driverは **薄いAPI呼び出し層** とする。

### 6.2 Driver が守るべき性質
- **Hard Stop 最優先**（通常出力より必ず優先）
- レート制限/飽和/デッドマンタイマ等により、暴走を抑える
- 最小限の **Actuation State** をCoreへ返す（学習の観測用）

### 6.3 音声 Driver（現時点の主対象）
- Chunk-based再生（例: 200〜500ms単位）
- Revision（付け足し/言い直し）は「未来チャンク差し替え」で吸収
- 抑揚/間/強調は「テキスト規則 + $u$」の合成で表現（マッピング詳細はDriver内）

### 6.4 将来のマルチモーダル
- マウス/キーボード/ロボット等はDriverとして追加
- それでも Core→Driver の契約（Action Plan）は増やさない

---

## 7. Hard Stop（安全停止）仕様

### 7.1 定義
`Hard_Stop_Signal` を受け取ったら、Driverは最優先で“止める”。

最低要件（音声の例）:
- 即時無音化（可能ならcallback内）
- 再生キュー破棄
- 可能ならストリーム停止→close→（必要なら）再open

### 7.2 計測（必須）
- publish→検知（無音化）
- publish→物理停止（stream inactive/close相当）

上記を分けてJSONLに保存し、p95/p99を確認する。

---

## 8. IPC（推奨）

### 8.1 通常経路
- Lock-free Ring Buffer（SPSC）で特徴量・イベント・Action Plan等を運ぶ

### 8.2 最優先経路
- 共有メモリのフラグ等で Hard Stop を伝える（通常経路を待たない）

### 8.3 低次元制御ベクトル
- 共有メモリの固定長ベクトル（seq付き）で $u$ を共有しても良い

---

## 9. KPI（評価指標）

### 9.1 Latency（遅延）
- Stop Latency（目標）: **Median < 50ms**, **p95 < 80ms**, **p99 < 100ms**

### 9.2 Safety（誤検知）
- False Positive: **< 0.5回/分**（実環境で長期）
- False Negative: **< 5%**

### 9.3 Experience（体験）
- 割り込み応答が「譲る/話し切る/待つ」を状況に応じて最適化できる
- 不自然なチャタリング（連打）が発生しない

---

## 10. 開発ロードマップ（新稿）

このロードマップは [docs/project/作業一覧_チェックリスト.md](../project/%E4%BD%9C%E6%A5%AD%E4%B8%80%E8%A6%A7_%E3%83%81%E3%82%A7%E3%83%83%E3%82%AF%E3%83%AA%E3%82%B9%E3%83%88.md) と一致させる。

### Phase 1: 停止の実測と安全停止の土台
- Step 1.0: Stop遅延の計測基盤（JSONL / p95/p99）
- Step 1.1: Reflex（暫定DSP→将来SNN置換）の安全検知
- Step 1.2: Hard Stopを“実デバイス停止”までE2Eで検証

### Phase 2: 短期記憶とオンライン更新
- Step 2.1: STP（Tsodyks–Markram等）を含むリザーバ
- Step 2.2: MC（Memory Capacity）探索で状態表現を評価
- Step 2.3: 状態ベクトル設計と次元削減（投影）
- Step 2.4: RLS等でReadoutをオンライン更新（安定設計）

### Phase 3: システム統合（単一SNN + Actuation Drivers）
- Step 3.1: Core→Driver I/O（Action Plan / Readout / Driver API）
- Step 3.2: マルチプロセス縦切り（入力→Core→Driver）と計測
- Step 3.3: 低遅延IPC（SPSC等）の実運用投入
- Step 3.4: Hard Stop最優先の回帰（退行検知）とSoft Interruptの学習導入

### Phase 4: 運用・可視化
- Step 4.1: Brain Visualizer（状態/スパイク/Driver状態の可視化）
- Step 4.2: 設定とチューニングの運用化（再現性・保存・共有）

---

## 11. 成果物の置き場所（運用）

- docs/
  - [docs/ガイド.md](../%E3%82%AC%E3%82%A4%E3%83%89.md)
  - [docs/spec/仕様書.md](%E4%BB%95%E6%A7%98%E6%9B%B8.md)（本書）
  - docs/howto/
  - docs/project/（チェックリスト・用語集・成果サマリ）
- outputs/
  - phase1/...
  - phase2/...
  - phase3/...
